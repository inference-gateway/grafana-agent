// Code generated by counterfeiter. DO NOT EDIT.
package promqlfakes

import (
	"context"
	"sync"

	"github.com/inference-gateway/grafana-agent/internal/promql"
)

type FakePromQL struct {
	DiscoverMetricsStub        func(context.Context, string, string, promql.MetricType) ([]promql.MetricInfo, error)
	discoverMetricsMutex       sync.RWMutex
	discoverMetricsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 promql.MetricType
	}
	discoverMetricsReturns struct {
		result1 []promql.MetricInfo
		result2 error
	}
	discoverMetricsReturnsOnCall map[int]struct {
		result1 []promql.MetricInfo
		result2 error
	}
	GenerateQueriesStub        func(*promql.MetricInfo) []promql.QuerySuggestion
	generateQueriesMutex       sync.RWMutex
	generateQueriesArgsForCall []struct {
		arg1 *promql.MetricInfo
	}
	generateQueriesReturns struct {
		result1 []promql.QuerySuggestion
	}
	generateQueriesReturnsOnCall map[int]struct {
		result1 []promql.QuerySuggestion
	}
	GetBestQueryStub        func([]promql.QuerySuggestion) promql.QuerySuggestion
	getBestQueryMutex       sync.RWMutex
	getBestQueryArgsForCall []struct {
		arg1 []promql.QuerySuggestion
	}
	getBestQueryReturns struct {
		result1 promql.QuerySuggestion
	}
	getBestQueryReturnsOnCall map[int]struct {
		result1 promql.QuerySuggestion
	}
	GetMetricMetadataStub        func(context.Context, string, string) (*promql.MetricInfo, error)
	getMetricMetadataMutex       sync.RWMutex
	getMetricMetadataArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getMetricMetadataReturns struct {
		result1 *promql.MetricInfo
		result2 error
	}
	getMetricMetadataReturnsOnCall map[int]struct {
		result1 *promql.MetricInfo
		result2 error
	}
	ValidateQueryStub        func(context.Context, string, string) error
	validateQueryMutex       sync.RWMutex
	validateQueryArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	validateQueryReturns struct {
		result1 error
	}
	validateQueryReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePromQL) DiscoverMetrics(arg1 context.Context, arg2 string, arg3 string, arg4 promql.MetricType) ([]promql.MetricInfo, error) {
	fake.discoverMetricsMutex.Lock()
	ret, specificReturn := fake.discoverMetricsReturnsOnCall[len(fake.discoverMetricsArgsForCall)]
	fake.discoverMetricsArgsForCall = append(fake.discoverMetricsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 promql.MetricType
	}{arg1, arg2, arg3, arg4})
	stub := fake.DiscoverMetricsStub
	fakeReturns := fake.discoverMetricsReturns
	fake.recordInvocation("DiscoverMetrics", []interface{}{arg1, arg2, arg3, arg4})
	fake.discoverMetricsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromQL) DiscoverMetricsCallCount() int {
	fake.discoverMetricsMutex.RLock()
	defer fake.discoverMetricsMutex.RUnlock()
	return len(fake.discoverMetricsArgsForCall)
}

func (fake *FakePromQL) DiscoverMetricsCalls(stub func(context.Context, string, string, promql.MetricType) ([]promql.MetricInfo, error)) {
	fake.discoverMetricsMutex.Lock()
	defer fake.discoverMetricsMutex.Unlock()
	fake.DiscoverMetricsStub = stub
}

func (fake *FakePromQL) DiscoverMetricsArgsForCall(i int) (context.Context, string, string, promql.MetricType) {
	fake.discoverMetricsMutex.RLock()
	defer fake.discoverMetricsMutex.RUnlock()
	argsForCall := fake.discoverMetricsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePromQL) DiscoverMetricsReturns(result1 []promql.MetricInfo, result2 error) {
	fake.discoverMetricsMutex.Lock()
	defer fake.discoverMetricsMutex.Unlock()
	fake.DiscoverMetricsStub = nil
	fake.discoverMetricsReturns = struct {
		result1 []promql.MetricInfo
		result2 error
	}{result1, result2}
}

func (fake *FakePromQL) DiscoverMetricsReturnsOnCall(i int, result1 []promql.MetricInfo, result2 error) {
	fake.discoverMetricsMutex.Lock()
	defer fake.discoverMetricsMutex.Unlock()
	fake.DiscoverMetricsStub = nil
	if fake.discoverMetricsReturnsOnCall == nil {
		fake.discoverMetricsReturnsOnCall = make(map[int]struct {
			result1 []promql.MetricInfo
			result2 error
		})
	}
	fake.discoverMetricsReturnsOnCall[i] = struct {
		result1 []promql.MetricInfo
		result2 error
	}{result1, result2}
}

func (fake *FakePromQL) GenerateQueries(arg1 *promql.MetricInfo) []promql.QuerySuggestion {
	fake.generateQueriesMutex.Lock()
	ret, specificReturn := fake.generateQueriesReturnsOnCall[len(fake.generateQueriesArgsForCall)]
	fake.generateQueriesArgsForCall = append(fake.generateQueriesArgsForCall, struct {
		arg1 *promql.MetricInfo
	}{arg1})
	stub := fake.GenerateQueriesStub
	fakeReturns := fake.generateQueriesReturns
	fake.recordInvocation("GenerateQueries", []interface{}{arg1})
	fake.generateQueriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromQL) GenerateQueriesCallCount() int {
	fake.generateQueriesMutex.RLock()
	defer fake.generateQueriesMutex.RUnlock()
	return len(fake.generateQueriesArgsForCall)
}

func (fake *FakePromQL) GenerateQueriesCalls(stub func(*promql.MetricInfo) []promql.QuerySuggestion) {
	fake.generateQueriesMutex.Lock()
	defer fake.generateQueriesMutex.Unlock()
	fake.GenerateQueriesStub = stub
}

func (fake *FakePromQL) GenerateQueriesArgsForCall(i int) *promql.MetricInfo {
	fake.generateQueriesMutex.RLock()
	defer fake.generateQueriesMutex.RUnlock()
	argsForCall := fake.generateQueriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromQL) GenerateQueriesReturns(result1 []promql.QuerySuggestion) {
	fake.generateQueriesMutex.Lock()
	defer fake.generateQueriesMutex.Unlock()
	fake.GenerateQueriesStub = nil
	fake.generateQueriesReturns = struct {
		result1 []promql.QuerySuggestion
	}{result1}
}

func (fake *FakePromQL) GenerateQueriesReturnsOnCall(i int, result1 []promql.QuerySuggestion) {
	fake.generateQueriesMutex.Lock()
	defer fake.generateQueriesMutex.Unlock()
	fake.GenerateQueriesStub = nil
	if fake.generateQueriesReturnsOnCall == nil {
		fake.generateQueriesReturnsOnCall = make(map[int]struct {
			result1 []promql.QuerySuggestion
		})
	}
	fake.generateQueriesReturnsOnCall[i] = struct {
		result1 []promql.QuerySuggestion
	}{result1}
}

func (fake *FakePromQL) GetBestQuery(arg1 []promql.QuerySuggestion) promql.QuerySuggestion {
	var arg1Copy []promql.QuerySuggestion
	if arg1 != nil {
		arg1Copy = make([]promql.QuerySuggestion, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getBestQueryMutex.Lock()
	ret, specificReturn := fake.getBestQueryReturnsOnCall[len(fake.getBestQueryArgsForCall)]
	fake.getBestQueryArgsForCall = append(fake.getBestQueryArgsForCall, struct {
		arg1 []promql.QuerySuggestion
	}{arg1Copy})
	stub := fake.GetBestQueryStub
	fakeReturns := fake.getBestQueryReturns
	fake.recordInvocation("GetBestQuery", []interface{}{arg1Copy})
	fake.getBestQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromQL) GetBestQueryCallCount() int {
	fake.getBestQueryMutex.RLock()
	defer fake.getBestQueryMutex.RUnlock()
	return len(fake.getBestQueryArgsForCall)
}

func (fake *FakePromQL) GetBestQueryCalls(stub func([]promql.QuerySuggestion) promql.QuerySuggestion) {
	fake.getBestQueryMutex.Lock()
	defer fake.getBestQueryMutex.Unlock()
	fake.GetBestQueryStub = stub
}

func (fake *FakePromQL) GetBestQueryArgsForCall(i int) []promql.QuerySuggestion {
	fake.getBestQueryMutex.RLock()
	defer fake.getBestQueryMutex.RUnlock()
	argsForCall := fake.getBestQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromQL) GetBestQueryReturns(result1 promql.QuerySuggestion) {
	fake.getBestQueryMutex.Lock()
	defer fake.getBestQueryMutex.Unlock()
	fake.GetBestQueryStub = nil
	fake.getBestQueryReturns = struct {
		result1 promql.QuerySuggestion
	}{result1}
}

func (fake *FakePromQL) GetBestQueryReturnsOnCall(i int, result1 promql.QuerySuggestion) {
	fake.getBestQueryMutex.Lock()
	defer fake.getBestQueryMutex.Unlock()
	fake.GetBestQueryStub = nil
	if fake.getBestQueryReturnsOnCall == nil {
		fake.getBestQueryReturnsOnCall = make(map[int]struct {
			result1 promql.QuerySuggestion
		})
	}
	fake.getBestQueryReturnsOnCall[i] = struct {
		result1 promql.QuerySuggestion
	}{result1}
}

func (fake *FakePromQL) GetMetricMetadata(arg1 context.Context, arg2 string, arg3 string) (*promql.MetricInfo, error) {
	fake.getMetricMetadataMutex.Lock()
	ret, specificReturn := fake.getMetricMetadataReturnsOnCall[len(fake.getMetricMetadataArgsForCall)]
	fake.getMetricMetadataArgsForCall = append(fake.getMetricMetadataArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetMetricMetadataStub
	fakeReturns := fake.getMetricMetadataReturns
	fake.recordInvocation("GetMetricMetadata", []interface{}{arg1, arg2, arg3})
	fake.getMetricMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromQL) GetMetricMetadataCallCount() int {
	fake.getMetricMetadataMutex.RLock()
	defer fake.getMetricMetadataMutex.RUnlock()
	return len(fake.getMetricMetadataArgsForCall)
}

func (fake *FakePromQL) GetMetricMetadataCalls(stub func(context.Context, string, string) (*promql.MetricInfo, error)) {
	fake.getMetricMetadataMutex.Lock()
	defer fake.getMetricMetadataMutex.Unlock()
	fake.GetMetricMetadataStub = stub
}

func (fake *FakePromQL) GetMetricMetadataArgsForCall(i int) (context.Context, string, string) {
	fake.getMetricMetadataMutex.RLock()
	defer fake.getMetricMetadataMutex.RUnlock()
	argsForCall := fake.getMetricMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromQL) GetMetricMetadataReturns(result1 *promql.MetricInfo, result2 error) {
	fake.getMetricMetadataMutex.Lock()
	defer fake.getMetricMetadataMutex.Unlock()
	fake.GetMetricMetadataStub = nil
	fake.getMetricMetadataReturns = struct {
		result1 *promql.MetricInfo
		result2 error
	}{result1, result2}
}

func (fake *FakePromQL) GetMetricMetadataReturnsOnCall(i int, result1 *promql.MetricInfo, result2 error) {
	fake.getMetricMetadataMutex.Lock()
	defer fake.getMetricMetadataMutex.Unlock()
	fake.GetMetricMetadataStub = nil
	if fake.getMetricMetadataReturnsOnCall == nil {
		fake.getMetricMetadataReturnsOnCall = make(map[int]struct {
			result1 *promql.MetricInfo
			result2 error
		})
	}
	fake.getMetricMetadataReturnsOnCall[i] = struct {
		result1 *promql.MetricInfo
		result2 error
	}{result1, result2}
}

func (fake *FakePromQL) ValidateQuery(arg1 context.Context, arg2 string, arg3 string) error {
	fake.validateQueryMutex.Lock()
	ret, specificReturn := fake.validateQueryReturnsOnCall[len(fake.validateQueryArgsForCall)]
	fake.validateQueryArgsForCall = append(fake.validateQueryArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ValidateQueryStub
	fakeReturns := fake.validateQueryReturns
	fake.recordInvocation("ValidateQuery", []interface{}{arg1, arg2, arg3})
	fake.validateQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromQL) ValidateQueryCallCount() int {
	fake.validateQueryMutex.RLock()
	defer fake.validateQueryMutex.RUnlock()
	return len(fake.validateQueryArgsForCall)
}

func (fake *FakePromQL) ValidateQueryCalls(stub func(context.Context, string, string) error) {
	fake.validateQueryMutex.Lock()
	defer fake.validateQueryMutex.Unlock()
	fake.ValidateQueryStub = stub
}

func (fake *FakePromQL) ValidateQueryArgsForCall(i int) (context.Context, string, string) {
	fake.validateQueryMutex.RLock()
	defer fake.validateQueryMutex.RUnlock()
	argsForCall := fake.validateQueryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromQL) ValidateQueryReturns(result1 error) {
	fake.validateQueryMutex.Lock()
	defer fake.validateQueryMutex.Unlock()
	fake.ValidateQueryStub = nil
	fake.validateQueryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromQL) ValidateQueryReturnsOnCall(i int, result1 error) {
	fake.validateQueryMutex.Lock()
	defer fake.validateQueryMutex.Unlock()
	fake.ValidateQueryStub = nil
	if fake.validateQueryReturnsOnCall == nil {
		fake.validateQueryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateQueryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromQL) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePromQL) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ promql.PromQL = new(FakePromQL)
